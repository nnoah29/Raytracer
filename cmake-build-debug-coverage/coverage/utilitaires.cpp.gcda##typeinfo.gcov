        -:    0:Source:/usr/include/c++/15.1.1/typeinfo
        -:    0:Graph:/home/nnoah/_WORKS/SCHooL_/RAYTRACER_/cmake-build-debug-coverage/CMakeFiles/raytracer.dir/utilitaires/utilitaires.cpp.gcno
        -:    0:Data:/home/nnoah/_WORKS/SCHooL_/RAYTRACER_/cmake-build-debug-coverage/CMakeFiles/raytracer.dir/utilitaires/utilitaires.cpp.gcda
        -:    0:Runs:1
        -:    1:// RTTI support for -*- C++ -*-
        -:    2:// Copyright (C) 1994-2025 Free Software Foundation, Inc.
        -:    3://
        -:    4:// This file is part of GCC.
        -:    5://
        -:    6:// GCC is free software; you can redistribute it and/or modify
        -:    7:// it under the terms of the GNU General Public License as published by
        -:    8:// the Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10://
        -:   11:// GCC is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15://
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file typeinfo
        -:   26: *  This is a Standard C++ Library header.
        -:   27: */
        -:   28:
        -:   29:#ifndef _TYPEINFO
        -:   30:#define _TYPEINFO
        -:   31:
        -:   32:#ifdef _GLIBCXX_SYSHDR
        -:   33:#pragma GCC system_header
        -:   34:#endif
        -:   35:
        -:   36:#include <bits/exception.h>
        -:   37:#if __cplusplus >= 201103L
        -:   38:#include <bits/hash_bytes.h>
        -:   39:#endif
        -:   40:
        -:   41:#define __glibcxx_want_constexpr_typeinfo
        -:   42:#include <bits/version.h>
        -:   43:
        -:   44:#pragma GCC visibility push(default)
        -:   45:
        -:   46:extern "C++" {
        -:   47:
        -:   48:namespace __cxxabiv1
        -:   49:{
        -:   50:  class __class_type_info;
        -:   51:} // namespace __cxxabiv1
        -:   52:
        -:   53:// Determine whether typeinfo names for the same type are merged (in which
        -:   54:// case comparison can just compare pointers) or not (in which case strings
        -:   55:// must be compared), and whether comparison is to be implemented inline or
        -:   56:// not.  We used to do inline pointer comparison by default if weak symbols
        -:   57:// are available, but even with weak symbols sometimes names are not merged
        -:   58:// when objects are loaded with RTLD_LOCAL, so now we always use strcmp by
        -:   59:// default.  For ABI compatibility, we do the strcmp inline if weak symbols
        -:   60:// are available, and out-of-line if not.  Out-of-line pointer comparison
        -:   61:// is used where the object files are to be portable to multiple systems,
        -:   62:// some of which may not be able to use pointer comparison, but the
        -:   63:// particular system for which libstdc++ is being built can use pointer
        -:   64:// comparison; in particular for most ARM EABI systems, where the ABI
        -:   65:// specifies out-of-line comparison.  The compiler's target configuration
        -:   66:// can override the defaults by defining __GXX_TYPEINFO_EQUALITY_INLINE to
        -:   67:// 1 or 0 to indicate whether or not comparison is inline, and
        -:   68:// __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to indicate whether or not pointer
        -:   69:// comparison can be used.
        -:   70:
        -:   71:#ifndef __GXX_MERGED_TYPEINFO_NAMES
        -:   72:// By default, typeinfo names are not merged.
        -:   73:#define __GXX_MERGED_TYPEINFO_NAMES 0
        -:   74:#endif
        -:   75:
        -:   76:// By default follow the old inline rules to avoid ABI changes.
        -:   77:#ifndef __GXX_TYPEINFO_EQUALITY_INLINE
        -:   78:#  if !__GXX_WEAK__
        -:   79:#    define __GXX_TYPEINFO_EQUALITY_INLINE 0
        -:   80:#  else
        -:   81:#    define __GXX_TYPEINFO_EQUALITY_INLINE 1
        -:   82:#  endif
        -:   83:#endif
        -:   84:
        -:   85:namespace std
        -:   86:{
        -:   87:  /**
        -:   88:   *  @brief  Part of RTTI.
        -:   89:   *
        -:   90:   *  The @c type_info class describes type information generated by
        -:   91:   *  an implementation.
        -:   92:  */
        -:   93:  class type_info
        -:   94:  {
        -:   95:  public:
        -:   96:    /** Destructor first. Being the first non-inline virtual function, this
        -:   97:     *  controls in which translation unit the vtable is emitted. The
        -:   98:     *  compiler makes use of that information to know where to emit
        -:   99:     *  the runtime-mandated type_info structures in the new-abi.  */
        -:  100:    virtual ~type_info();
        -:  101:
        -:  102:    /** Returns an @e implementation-defined byte string; this is not
        -:  103:     *  portable between compilers!  */
function _ZNKSt9type_info4nameEv called 0 returned 0% blocks executed 0%
    #####:  104:    const char* name() const _GLIBCXX_NOEXCEPT
    #####:  105:    { return __name[0] == '*' ? __name + 1 : __name; }
    %%%%%:  105-block 2
branchement  0 jamais exécuté (fallthrough)
branchement  1 jamais exécuté
    %%%%%:  105-block 3
    %%%%%:  105-block 4
    %%%%%:  105-block 5
        -:  106:
        -:  107:    /** Returns true if `*this` precedes `__arg` in the implementation's
        -:  108:     *  collation order.  */
        -:  109:    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
        -:  110:
        -:  111:    _GLIBCXX23_CONSTEXPR
        -:  112:    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
        -:  113:
        -:  114:#if __cpp_impl_three_way_comparison < 201907L
        -:  115:    bool operator!=(const type_info& __arg) const _GLIBCXX_NOEXCEPT
        -:  116:    { return !operator==(__arg); }
        -:  117:#endif
        -:  118:
        -:  119:#if __cplusplus >= 201103L
        -:  120:    size_t hash_code() const noexcept
        -:  121:    {
        -:  122:#  if !__GXX_MERGED_TYPEINFO_NAMES
        -:  123:      return _Hash_bytes(name(), __builtin_strlen(name()),
        -:  124:			 static_cast<size_t>(0xc70f6907UL));
        -:  125:#  else
        -:  126:      return reinterpret_cast<size_t>(__name);
        -:  127:#  endif
        -:  128:    }
        -:  129:#endif // C++11
        -:  130:
        -:  131:    // Return true if this is a pointer type of some kind
        -:  132:    virtual bool __is_pointer_p() const;
        -:  133:
        -:  134:    // Return true if this is a function type
        -:  135:    virtual bool __is_function_p() const;
        -:  136:
        -:  137:    // Try and catch a thrown type. Store an adjusted pointer to the
        -:  138:    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
        -:  139:    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
        -:  140:    // type, then THR_OBJ is the pointer itself. OUTER indicates the
        -:  141:    // number of outer pointers, and whether they were const
        -:  142:    // qualified.
        -:  143:    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
        -:  144:			    unsigned __outer) const;
        -:  145:
        -:  146:    // Internally used during catch matching
        -:  147:    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        -:  148:			     void **__obj_ptr) const;
        -:  149:
        -:  150:  protected:
        -:  151:    const char *__name;
        -:  152:
        -:  153:    explicit type_info(const char *__n): __name(__n) { }
        -:  154:
        -:  155:  private:
        -:  156:    // type_info objects cannot be copied.
        -:  157:#if __cplusplus >= 201103L
        -:  158:    type_info& operator=(const type_info&) = delete;
        -:  159:    type_info(const type_info&) = delete;
        -:  160:#else
        -:  161:    type_info& operator=(const type_info&);
        -:  162:    type_info(const type_info&);
        -:  163:#endif
        -:  164:
        -:  165:#if ! __GXX_TYPEINFO_EQUALITY_INLINE
        -:  166:    bool __equal(const type_info&) const _GLIBCXX_NOEXCEPT;
        -:  167:#endif
        -:  168:  };
        -:  169:
        -:  170:#if __GXX_TYPEINFO_EQUALITY_INLINE
        -:  171:  inline bool
        -:  172:  type_info::before(const type_info& __arg) const _GLIBCXX_NOEXCEPT
        -:  173:  {
        -:  174:#if !__GXX_MERGED_TYPEINFO_NAMES
        -:  175:    // Even with the new abi, on systems that support dlopen
        -:  176:    // we can run into cases where type_info names aren't merged,
        -:  177:    // so we still need to do string comparison.
        -:  178:    if (__name[0] != '*' || __arg.__name[0] != '*')
        -:  179:      return __builtin_strcmp (__name, __arg.__name) < 0;
        -:  180:#else
        -:  181:    // On some targets we can rely on type_info's NTBS being unique,
        -:  182:    // and therefore address comparisons are sufficient.
        -:  183:#endif
        -:  184:
        -:  185:    // In old abi, or when weak symbols are not supported, there can
        -:  186:    // be multiple instances of a type_info object for one
        -:  187:    // type. Uniqueness must use the __name value, not object address.
        -:  188:    return __name < __arg.__name;
        -:  189:  }
        -:  190:#endif
        -:  191:
        -:  192:#if __GXX_TYPEINFO_EQUALITY_INLINE || __cplusplus > 202002L
        -:  193:# if ! __GXX_TYPEINFO_EQUALITY_INLINE
        -:  194:  [[__gnu__::__always_inline__]]
        -:  195:# endif
        -:  196:  _GLIBCXX23_CONSTEXPR inline bool
function _ZNKSt9type_infoeqERKS_ called 0 returned 0% blocks executed 0%
    #####:  197:  type_info::operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    %%%%%:  197-block 2
        -:  198:  {
    #####:  199:    if (std::__is_constant_evaluated())
    %%%%%:  199-block 4
branchement  0 jamais exécuté (fallthrough)
branchement  1 jamais exécuté
    #####:  200:      return this == &__arg;
    %%%%%:  200-block 5
        -:  201:
    #####:  202:    if (__name == __arg.__name)
    %%%%%:  202-block 6
branchement  0 jamais exécuté (fallthrough)
branchement  1 jamais exécuté
    #####:  203:      return true;
    %%%%%:  203-block 7
        -:  204:
        -:  205:#if !__GXX_TYPEINFO_EQUALITY_INLINE
        -:  206:    // ABI requires comparisons to be non-inline.
        -:  207:    return __equal(__arg);
        -:  208:#elif !__GXX_MERGED_TYPEINFO_NAMES
        -:  209:    // Need to do string comparison.
    #####:  210:    return __name[0] != '*' && __builtin_strcmp (__name, __arg.name()) == 0;
    %%%%%:  210-block 8
branchement  0 jamais exécuté (fallthrough)
branchement  1 jamais exécuté
    %%%%%:  210-block 9
appel   2 jamais exécuté
branchement  3 jamais exécuté (fallthrough)
branchement  4 jamais exécuté
    %%%%%:  210-block 11
    %%%%%:  210-block 12
    %%%%%:  210-block 13
        -:  211:#else
        -:  212:    return false;
        -:  213:#endif
        -:  214:  }
        -:  215:#endif
        -:  216:
        -:  217:
        -:  218:  /**
        -:  219:   *  @brief  Thrown during incorrect typecasting.
        -:  220:   *  @ingroup exceptions
        -:  221:   *
        -:  222:   *  If you attempt an invalid @c dynamic_cast expression, an instance of
        -:  223:   *  this class (or something derived from this class) is thrown.  */
        -:  224:  class bad_cast : public exception
        -:  225:  {
        -:  226:  public:
        -:  227:    bad_cast() _GLIBCXX_USE_NOEXCEPT { }
        -:  228:
        -:  229:    // This declaration is not useless:
        -:  230:    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
        -:  231:    virtual ~bad_cast() _GLIBCXX_USE_NOEXCEPT;
        -:  232:
        -:  233:    // See comment in eh_exception.cc.
        -:  234:    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
        -:  235:  };
        -:  236:
        -:  237:  /**
        -:  238:   *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
        -:  239:   *  @ingroup exceptions
        -:  240:   */
        -:  241:  class bad_typeid : public exception
        -:  242:  {
        -:  243:  public:
        -:  244:    bad_typeid () _GLIBCXX_USE_NOEXCEPT { }
        -:  245:
        -:  246:    // This declaration is not useless:
        -:  247:    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
        -:  248:    virtual ~bad_typeid() _GLIBCXX_USE_NOEXCEPT;
        -:  249:
        -:  250:    // See comment in eh_exception.cc.
        -:  251:    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
        -:  252:  };
        -:  253:} // namespace std
        -:  254:
        -:  255:} // extern "C++"
        -:  256:
        -:  257:#pragma GCC visibility pop
        -:  258:
        -:  259:#endif
